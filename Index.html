<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Solar System Resume</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }
    #resume-overlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.9);
      color: #fff;
      padding: 20px;
      border-radius: 10px;
      display: none;
      z-index: 10;
    }
    .overlay-content {
      text-align: center;
    }
    .close-btn {
      background: #ff4d4d;
      border: none;
      color: white;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
    }
    .close-btn:hover {
      background: #ff1a1a;
    }
  </style>
</head>
<body>
  <div id="resume-overlay">
    <div class="overlay-content">
      <h2 class="section-title"></h2>
      <div class="resume-details"></div>
      <button class="close-btn" onclick="document.getElementById('resume-overlay').style.display='none'">Close</button>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    camera.position.z = 50;

    // OrbitControls for zoom and pan
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Starfield background
    function createStarField() {
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(10000 * 3);
      for (let i = 0; i < 10000; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 2000;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const stars = new THREE.Points(geometry, new THREE.PointsMaterial({ color: 0xFFFFFF }));
      scene.add(stars);
    }
    createStarField();

    // Planet class
    class ResumePlanet {
      constructor(texturePath, radius, orbitalRadius, resumeData) {
        this.group = new THREE.Group();
        this.resumeData = resumeData;

        // Planet texture and material
        const texture = new THREE.TextureLoader().load(texturePath);
        const material = new THREE.MeshPhongMaterial({ map: texture });
        this.sphere = new THREE.Mesh(new THREE.SphereGeometry(radius, 32, 32), material);

        // Orbital properties
        this.orbitalRadius = orbitalRadius;
        this.angle = Math.random() * Math.PI * 2;

        this.group.add(this.sphere);
        scene.add(this.group);

        // Create orbit path (circular line)
        const orbitGeometry = new THREE.CircleGeometry(this.orbitalRadius, 100);
        orbitGeometry.vertices.shift(); // Remove center point
        const orbitMaterial = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.5, transparent: true });
        this.orbit = new THREE.LineLoop(orbitGeometry, orbitMaterial);
        scene.add(this.orbit);
      }

      updateOrbit() {
        this.angle += 0.01 / this.orbitalRadius; // Adjust speed based on orbital radius
        this.group.position.x = Math.cos(this.angle) * this.orbitalRadius;
        this.group.position.z = Math.sin(this.angle) * this.orbitalRadius;
        this.sphere.rotation.y += 0.01; // Rotate planet on its axis
        this.orbit.rotation.x = Math.PI / 2; // Keep orbit on the horizontal plane
      }
    }

    // Sun
    const sun = new THREE.Mesh(
      new THREE.SphereGeometry(5, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xffffff })
    );
    scene.add(sun);

    // Lighting
    const pointLight = new THREE.PointLight(0xffffff, 2, 100);
    pointLight.position.set(0, 0, 0);
    scene.add(pointLight);

    // Planets with resume data
    const planets = [];
    planets.push(new ResumePlanet('https://planet-textures.s3.amazonaws.com/earth.jpg', 2, 20, { title: 'Education', content: 'Your degree details go here.' }));
    planets.push(new ResumePlanet('https://planet-textures.s3.amazonaws.com/mars.jpg', 1.5, 30, { title: 'Experience', content: 'Your work experience goes here.' }));
    planets.push(new ResumePlanet('https://planet-textures.s3.amazonaws.com/jupiter.jpg', 4, 40, { title: 'Skills', content: 'Your skills go here.' }));

    // Raycaster for interactivity
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    window.addEventListener('click', (event) => {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);

      if (intersects.length > 0) {
        const clickedPlanet = intersects[0].object.parent.resumeData;
        if (clickedPlanet) {
          document.getElementById('resume-overlay').style.display = 'block';
          document.querySelector('.section-title').textContent = clickedPlanet.title;
          document.querySelector('.resume-details').textContent = clickedPlanet.content;
        }
      }
    });

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      planets.forEach((planet) => planet.updateOrbit());
      renderer.render(scene, camera);
    }
    animate();

    // Responsive handling
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
